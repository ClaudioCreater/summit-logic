# -*- coding: utf-8 -*-
"""
===========================================================
  스마트스토어 × 대한통운 LOIS 송장번호 자동 매칭 프로그램
===========================================================
[흐름 요약]
  1단계: 더미 엑셀 2개 생성 (dummy_smart.xlsx / dummy_cj.xlsx)
  2단계: 두 파일을 읽어 '상품주문번호' ↔ '고객주문번호' 기준으로 매칭
  3단계: 대한통운 '운송장번호' → 스마트스토어 '송장번호'로 복사
  4단계: 매칭 결과를 final_upload.xlsx 로 저장

[필요 라이브러리 설치]
  pip install pandas openpyxl
===========================================================
"""

import sys
from pathlib import Path

import pandas as pd


# ===========================================================
# ① 더미 데이터 생성: 대한통운 LOIS 결과 파일 (dummy_cj.xlsx)
# ===========================================================

def create_dummy_cj_excel(file_path: str = "dummy_cj.xlsx") -> None:
    """
    대한통운 LOIS 시스템에서 다운로드하는 '송장 발급 결과' 파일을
    가짜(더미) 데이터로 생성해 엑셀로 저장합니다.

    핵심 컬럼:
      - 고객주문번호 : 스마트스토어 '상품주문번호'와 동일한 값 → 매칭 키
      - 운송장번호   : CJ가 발급한 실제 송장 번호 → 스마트스토어에 입력할 값
    """

    # -------------------------------------------------------
    # 가짜 데이터 딕셔너리 정의
    # 실제 LOIS 파일에는 훨씬 많은 컬럼이 있지만, 여기서는 핵심 컬럼만 구성
    # -------------------------------------------------------
    cj_data = {
        # 대한통운 LOIS에서 '고객주문번호' = 스마트스토어 '상품주문번호'
        "고객주문번호": [
            "20260223-000001",
            "20260223-000002",
            "20260223-000003",
            "20260223-000005",   # ← 스마트스토어에는 없는 번호 (CJ에만 존재하는 케이스)
        ],
        # CJ가 발급한 운송장 번호 (이 값을 스마트스토어 '송장번호'에 채워야 함)
        "운송장번호": [
            "621900000001",
            "621900000002",
            "621900000003",
            "621900000004",
        ],
        # 수취인 정보 (LOIS 파일에 원래 포함되어 있는 항목들)
        "수취인명": ["홍길동", "김철수", "이영희", "최지훈"],
        "수취인전화번호": [
            "010-1111-2222",
            "010-2222-3333",
            "010-3333-4444",
            "010-9999-8888",
        ],
        "배송지주소": [
            "서울특별시 강남구 테헤란로 1",
            "서울특별시 마포구 월드컵로 2",
            "경기도 성남시 분당구 정자일로 3",
            "인천광역시 연수구 컨벤시아대로 4",
        ],
        # 상품 정보
        "상품명": ["무선 마우스", "기계식 키보드", "블루투스 이어폰", "게이밍 패드"],
        # 배송 처리 상태
        "배송상태": ["집하완료", "배송중", "배송완료", "집하완료"],
        # 접수(집하) 일자
        "집하일자": [
            "2026-02-23",
            "2026-02-23",
            "2026-02-23",
            "2026-02-23",
        ],
    }

    df_cj = pd.DataFrame(cj_data)

    # index=False : 엑셀에 행 번호(0,1,2…) 컬럼이 추가되지 않도록 설정
    df_cj.to_excel(file_path, index=False)
    print(f"[생성 완료] 대한통운 LOIS 더미 파일 -> {file_path}  (총 {len(df_cj)}건)")


# ===========================================================
# ② 더미 데이터 생성: 스마트스토어 배송 업로드 양식 (dummy_smart.xlsx)
# ===========================================================

def create_dummy_smart_excel(file_path: str = "dummy_smart.xlsx") -> None:
    """
    네이버 스마트스토어 '발주(주문) 확인/발송 관리'에서 다운로드하는
    배송 업로드 양식 파일을 가짜(더미) 데이터로 생성해 엑셀로 저장합니다.

    핵심 컬럼:
      - 상품주문번호 : 주문 건별 고유 번호 → 대한통운 '고객주문번호'와 매칭
      - 송장번호     : 현재 비어 있음 → 프로그램이 자동으로 채워 줄 컬럼
    """

    smart_data = {
        # 스마트스토어에서 발급하는 주문 고유 번호 (매칭의 기준 키)
        "상품주문번호": [
            "20260223-000001",
            "20260223-000002",
            "20260223-000003",
            "20260223-000004",   # ← 대한통운 파일에는 없는 번호 (미발급 처리 대상)
        ],
        # 주문 번호 (상품주문번호와 다른 개념; 1개 주문에 여러 상품주문번호 가능)
        "주문번호": [
            "2026022300001",
            "2026022300002",
            "2026022300003",
            "2026022300004",
        ],
        # 수취인 정보
        "수취인명": ["홍길동", "김철수", "이영희", "박민수"],
        "수취인연락처1": [
            "010-1111-2222",
            "010-2222-3333",
            "010-3333-4444",
            "010-4444-5555",
        ],
        "수취인우편번호": ["01234", "04567", "07890", "12345"],
        "수취인주소": [
            "서울특별시 강남구 테헤란로 1",
            "서울특별시 마포구 월드컵로 2",
            "경기도 성남시 분당구 정자일로 3",
            "부산광역시 해운대구 해운대로 4",
        ],
        # 주문 상품 정보
        "상품명": ["무선 마우스", "기계식 키보드", "블루투스 이어폰", "USB 허브"],
        "옵션정보": ["블랙", "청축", "화이트", "4포트"],
        "수량": [1, 1, 2, 1],
        # 택배사 / 송장번호: 원래 비어 있거나 직접 입력하는 칸
        # → 이 프로그램이 자동으로 채워 줍니다
        "택배사": [""] * 4,
        "송장번호": [""] * 4,     # ← 채워야 할 핵심 컬럼
    }

    df_smart = pd.DataFrame(smart_data)
    df_smart.to_excel(file_path, index=False)
    print(f"[생성 완료] 스마트스토어 더미 파일  -> {file_path}  (총 {len(df_smart)}건)")


# ===========================================================
# ③ 핵심 로직: 두 파일 매칭 후 final_upload.xlsx 생성
# ===========================================================

def create_final_upload_file(
    smart_file: str = "dummy_smart.xlsx",
    cj_file: str = "dummy_cj.xlsx",
    output_file: str = "final_upload.xlsx",
) -> None:
    """
    [매칭 원리]
      스마트스토어  '상품주문번호'
           ↕  (같은 값)
      대한통운 LOIS '고객주문번호'

    매칭이 되면 → 대한통운 '운송장번호'를 스마트스토어 '송장번호'에 복사
    매칭 안 되면 → '송장번호' 칸에 '미발급' 표시 (엑셀 업로드 시 에러 방지)

    최종 저장: final_upload.xlsx (스마트스토어 업로드에 필요한 컬럼만 포함)
    """

    # ----------------------------------------------------------
    # STEP 1. 파일 존재 여부 확인
    #         파일이 없으면 알기 쉬운 오류 메시지를 출력하고 프로그램 종료
    # ----------------------------------------------------------
    for path in [smart_file, cj_file]:
        if not Path(path).exists():
            print(f"\n[오류] 파일을 찾을 수 없습니다: {path}")
            print("  → create_dummy_smart_excel() / create_dummy_cj_excel() 을 먼저 실행하세요.")
            sys.exit(1)

    # ----------------------------------------------------------
    # STEP 2. 엑셀 파일 불러오기
    #         dtype=str : 주문번호가 숫자처럼 보여도 문자열로 읽어
    #                     앞자리 0이 사라지거나 형식이 바뀌는 것을 방지
    # ----------------------------------------------------------
    print("\n[1단계] 파일 불러오는 중...")
    df_smart = pd.read_excel(smart_file, dtype=str)
    df_cj    = pd.read_excel(cj_file,    dtype=str)

    print(f"  · 스마트스토어 주문 건수 : {len(df_smart):>4}건  ({smart_file})")
    print(f"  · 대한통운 LOIS  건수   : {len(df_cj):>4}건  ({cj_file})")

    # ----------------------------------------------------------
    # STEP 3. 대한통운 파일에서 매칭에 필요한 컬럼만 추출
    #         '고객주문번호'와 '운송장번호' 두 개만 있으면 충분
    # ----------------------------------------------------------
    print("\n[2단계] 대한통운 파일에서 매칭 키 컬럼 추출 중...")

    # 필수 컬럼이 실제로 존재하는지 검증
    required_cj_cols = ["고객주문번호", "운송장번호"]
    missing = [c for c in required_cj_cols if c not in df_cj.columns]
    if missing:
        print(f"[오류] 대한통운 파일에 필수 컬럼이 없습니다: {missing}")
        print(f"  → 실제 컬럼 목록: {list(df_cj.columns)}")
        sys.exit(1)

    # 매칭에 쓸 컬럼만 추출 (불필요한 컬럼이 merge 후 섞이지 않도록)
    df_cj_key = df_cj[["고객주문번호", "운송장번호"]].copy()

    # 혹시 같은 고객주문번호가 CJ 파일에 중복으로 있다면 첫 번째 것만 사용
    # (중복이 있으면 merge 후 스마트스토어 행이 여러 개로 늘어날 수 있음)
    before_dedup = len(df_cj_key)
    df_cj_key = df_cj_key.drop_duplicates(subset="고객주문번호", keep="first")
    after_dedup = len(df_cj_key)
    if before_dedup != after_dedup:
        print(f"  ⚠ 대한통운 파일에 중복 고객주문번호 발견 → {before_dedup - after_dedup}건 제거 (첫 번째 유지)")

    # ----------------------------------------------------------
    # STEP 4. 두 데이터프레임을 LEFT JOIN 방식으로 병합(merge)
    #
    #   LEFT JOIN 이란?
    #   → 스마트스토어 주문 목록을 기준(왼쪽)으로 유지하면서
    #     대한통운 파일에 해당 주문번호가 있으면 운송장번호를 붙여 줍니다.
    #   → 대한통운 파일에 없는 주문번호는 운송장번호 칸이 빈칸(NaN)이 됩니다.
    #
    #   left_on  : 스마트스토어 기준 컬럼 이름
    #   right_on : 대한통운 기준 컬럼 이름
    #   (두 파일의 컬럼 이름이 달라서 left_on / right_on 을 따로 지정)
    # ----------------------------------------------------------
    print("\n[3단계] 상품주문번호 ↔ 고객주문번호 기준으로 매칭 중...")

    df_merged = pd.merge(
        left=df_smart,          # 왼쪽: 스마트스토어 (기준 파일)
        right=df_cj_key,        # 오른쪽: 대한통운 키 컬럼
        left_on="상품주문번호",  # 스마트스토어의 키 컬럼
        right_on="고객주문번호", # 대한통운의 키 컬럼
        how="left",             # 스마트스토어 주문은 모두 유지
    )

    # ----------------------------------------------------------
    # STEP 5. 매칭 결과를 '송장번호' 컬럼에 반영
    #
    #   - 매칭 성공: 대한통운 '운송장번호' 값을 '송장번호'에 복사
    #   - 매칭 실패: '운송장번호'가 NaN → '미발급' 문자열로 채움
    #               (스마트스토어 업로드 시 빈칸이면 에러 날 수 있어 '미발급' 사용)
    # ----------------------------------------------------------
    print("\n[4단계] 운송장번호 → 송장번호 컬럼 복사 및 미발급 처리 중...")

    # '운송장번호' 컬럼 값을 그대로 '송장번호' 컬럼에 덮어씀
    # fillna('미발급') : NaN(매칭 안 된 것)은 '미발급'으로 채움
    df_merged["송장번호"] = df_merged["운송장번호"].fillna("미발급")

    # 택배사도 함께 채워 줌 (매칭 성공한 건만 CJ대한통운으로 표시)
    df_merged["택배사"] = df_merged["운송장번호"].apply(
        lambda x: "CJ대한통운" if pd.notna(x) and x != "" else "미발급"
    )

    # merge 과정에서 생긴 임시 컬럼 '고객주문번호', '운송장번호' 제거
    df_merged.drop(columns=["고객주문번호", "운송장번호"], errors="ignore", inplace=True)

    # ----------------------------------------------------------
    # STEP 6. 스마트스토어 업로드에 필요한 컬럼 순서로 정리
    #         (불필요한 컬럼 제거 + 순서 통일)
    # ----------------------------------------------------------
    print("\n[5단계] 최종 업로드 양식에 맞게 컬럼 정리 중...")

    final_columns = [
        "상품주문번호",    # 매칭 기준 키 (스마트스토어 업로드 시 필수)
        "주문번호",        # 주문 묶음 번호
        "수취인명",        # 받는 분 성함
        "수취인연락처1",   # 받는 분 연락처
        "수취인우편번호",  # 우편번호
        "수취인주소",      # 배송지 주소
        "상품명",          # 주문 상품명
        "옵션정보",        # 옵션 (색상, 사이즈 등)
        "수량",            # 주문 수량
        "택배사",          # CJ대한통운 or 미발급
        "송장번호",        # ★ 핵심: 대한통운 운송장번호가 들어가는 칸
    ]

    # 위 컬럼 중 실제 데이터프레임에 없는 컬럼은 건너뜀 (KeyError 방지)
    existing_columns = [c for c in final_columns if c in df_merged.columns]
    df_final = df_merged[existing_columns].copy()

    # ----------------------------------------------------------
    # STEP 7. 매칭 결과 통계 출력
    #         사장님이 결과를 한눈에 확인할 수 있도록 요약 정보 제공
    # ----------------------------------------------------------
    total      = len(df_final)
    matched    = (df_final["송장번호"] != "미발급").sum()
    unmatched  = total - matched

    print("\n" + "=" * 50)
    print("  [매칭 결과 요약]")
    print("=" * 50)
    print(f"  전체 주문 건수    : {total:>4}건")
    print(f"  [OK] 송장 매칭 성공: {matched:>4}건")
    print(f"  [!!] 송장 미발급  : {unmatched:>4}건")
    print("=" * 50)

    # 미발급 건이 있으면 어떤 주문번호인지 따로 출력
    if unmatched > 0:
        unmatched_orders = df_final.loc[df_final["송장번호"] == "미발급", "상품주문번호"].tolist()
        print("  [미발급 주문번호 목록]")
        for order_no in unmatched_orders:
            print(f"    - {order_no}")
        print()

    # ----------------------------------------------------------
    # STEP 8. 최종 파일 저장
    # ----------------------------------------------------------
    df_final.to_excel(output_file, index=False)
    print(f"[저장 완료] 최종 업로드 파일 -> {output_file}")

    # 결과 미리보기 (상위 5행 출력)
    print("\n[미리보기] final_upload.xlsx 상위 5행:")
    print(df_final.to_string(index=False, max_rows=5))


# ===========================================================
# 메인 실행부: 이 파일을 직접 실행할 때만 아래 코드가 동작합니다.
# ===========================================================

if __name__ == "__main__":

    print("=" * 60)
    print("  스마트스토어 × 대한통운 LOIS 송장번호 자동 매칭 프로그램")
    print("=" * 60)

    # ─── 1단계: 더미 엑셀 파일 2개 생성 ───
    print("\n[1/2] 더미 파일 생성 시작...")
    create_dummy_cj_excel("dummy_cj.xlsx")
    create_dummy_smart_excel("dummy_smart.xlsx")

    # ─── 2단계: 매칭 후 최종 업로드 파일 생성 ───
    print("\n[2/2] 송장번호 매칭 시작...")
    create_final_upload_file(
        smart_file="dummy_smart.xlsx",
        cj_file="dummy_cj.xlsx",
        output_file="final_upload.xlsx",
    )

    print("\n[완료] 모든 작업이 완료되었습니다.")
    print("   -> 'final_upload.xlsx' 파일을 스마트스토어에 업로드하세요.")
